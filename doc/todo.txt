NEXT STEPS:

**) Implement a couple of builtins to see how it goes...
    -> need some way to iterate over all builtins (for adding them to global env?)
**) Cautiously start implementing the VM?

**) MEMORY MANAGEMENT!!!! GC!!!!!
    hard problem... probably just leave it for later (when my tests pass...)

*) Does equality work correctly? "same object" should be recognized by it (in Python by object id comparison)
5) VM in C


VM instructions
===============

The following are instructions in their original form, before being assembled
to actual bytecode.


Opcode              Args        Description
------              ----        -----------

CONST               val         Push constant value to stack

LOADVAR             sym         Push var value to stack

STOREVAR            sym         Place TOS in var and pop stack

DEFVAR              sym         Define var to be the value in TOS and pop stack

FUNCTION            fn          Make closure from fn and current env, and push
                                it onto stack.

POP                             Pop value from stack

FJUMP               label       Jump if TOS is false to label and pop stack

JUMP                label       Jump to label

RETURN                          Return from function to last return point

CALL                n           Call function that's in TOS, saving
                                return point. n - number of arguments passed.


RANDOM THOUGHTS
===============

(*) I think I'll leave internal definitions be. R5RS allows internal definitions
    only in the beginning of blocks anyway. Doing the scanning out and convertion
    to letrec will just convolute the resulting bytecode with another layer of 
    'lambda'. This is tangential to my goals with Bob.
 
(*) Negative numbers: currently no way to create them, except (- 0 2). Should I bother?

